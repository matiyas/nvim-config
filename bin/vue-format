#!/usr/bin/env node

const fs = require("fs")
const { execSync } = require("child_process")

let input = ""
process.stdin.setEncoding("utf8")
process.stdin.on("data", (chunk) => (input += chunk))
process.stdin.on("end", () => {
  try {
    const result = formatVue(input)
    process.stdout.write(result)
  } catch (e) {
    console.error(e.message)
    process.exit(1)
  }
})

function extractSection(content, tagName) {
  const openTagRegex = new RegExp(`<${tagName}(\\s[^>]*)?>`, "gi")
  const closeTag = `</${tagName}>`

  const openMatch = openTagRegex.exec(content)
  if (!openMatch) return null

  const attrs = openMatch[1] || ""
  let startIndex = openMatch.index + openMatch[0].length
  let depth = 1
  let i = startIndex

  while (i < content.length && depth > 0) {
    const remainingContent = content.slice(i)
    const nextOpen = remainingContent.search(new RegExp(`<${tagName}(\\s|>)`, "i"))
    const nextClose = remainingContent.toLowerCase().indexOf(closeTag.toLowerCase())

    if (nextClose === -1) break

    if (nextOpen !== -1 && nextOpen < nextClose) {
      depth++
      i += nextOpen + 1
    } else {
      depth--
      if (depth === 0) {
        return {
          attrs,
          content: content.slice(startIndex, i + nextClose)
        }
      }
      i += nextClose + closeTag.length
    }
  }
  return null
}

function formatVue(content) {
  const templateMatch = extractSection(content, "template")
  const scriptMatch = extractSection(content, "script")
  const styleMatch = extractSection(content, "style")

  let result = ""

  if (templateMatch) {
    const formattedTemplate = formatHtml(templateMatch.content)
    const indentedTemplate = formattedTemplate
      .split("\n")
      .map(line => line.length > 0 ? "  " + line : line)
      .join("\n")
    result += "<template" + templateMatch.attrs + ">\n" + indentedTemplate + "\n</template>\n"
  }

  if (scriptMatch) {
    const formattedScript = formatWithPrettier(scriptMatch.content.trim(), "babel")
    result += "\n<script" + scriptMatch.attrs + ">\n" + formattedScript + "\n</script>\n"
  }

  if (styleMatch) {
    const lang = styleMatch.attrs.includes("scss") ? "scss" : "css"
    const formattedStyle = formatWithPrettier(styleMatch.content.trim(), lang)
    result += "\n<style" + styleMatch.attrs + ">\n" + formattedStyle + "\n</style>\n"
  }

  return result
}

function formatHtml(html) {
  const tmpFile = "/tmp/vue-format-" + process.pid + ".html"
  fs.writeFileSync(tmpFile, html)

  try {
    const result = execSync(
      "npx js-beautify --type html --indent-size 2 --wrap-attributes force-aligned --wrap-line-length 120 --indent-inner-html --preserve-newlines --max-preserve-newlines 2 " + tmpFile,
      { encoding: "utf8", maxBuffer: 10 * 1024 * 1024 }
    )
    return result.trimEnd()
  } finally {
    fs.unlinkSync(tmpFile)
  }
}

function formatWithPrettier(code, parser) {
  const tmpFile = "/tmp/vue-format-" + process.pid + "-" + parser + ".tmp"
  fs.writeFileSync(tmpFile, code)

  try {
    const result = execSync(
      "npx prettier --parser " + parser + " --semi false --single-quote --trailing-comma none --tab-width 2 --print-width 120 " + tmpFile,
      { encoding: "utf8", maxBuffer: 10 * 1024 * 1024 }
    )
    return result.trimEnd()
  } finally {
    fs.unlinkSync(tmpFile)
  }
}
